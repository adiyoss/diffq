<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>diffq.base API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>diffq.base</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) Facebook, Inc. and its affiliates.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.

from dataclasses import dataclass
from concurrent import futures
from fnmatch import fnmatch
from functools import partial
import io
import math
from multiprocessing import cpu_count
import typing as tp
import zlib

import torch


class BaseQuantizer:
    @dataclass
    class _QuantizedParam:
        name: str
        param: torch.nn.Parameter
        module: torch.nn.Module
        # If a Parameter is used multiple times, `other` can be used
        # to share state between the different Quantizers
        other: tp.Optional[tp.Any]

    def __init__(self, model: torch.nn.Module, min_size: float = 0.01, float16: bool = False,
                 exclude: tp.Optional[tp.List[str]] = [], detect_bound: bool = True):
        self.model = model
        self.min_size = min_size
        self.float16 = float16
        self.exclude = exclude
        self.detect_bound = detect_bound
        self._quantized = False
        self._pre_handle = self.model.register_forward_pre_hook(self._forward_pre_hook)
        self._post_handle = self.model.register_forward_hook(self._forward_hook)

        self._quantized_state = None
        self._qparams = []
        self._float16 = []
        self._others = []
        self._rnns = []

        self._saved = []

        self._find_params()

    def _find_params(self):
        min_params = self.min_size * 2**20 // 4
        previous = {}
        for module_name, module in self.model.named_modules():
            if isinstance(module, torch.nn.RNNBase):
                self._rnns.append(module)
            for name, param in list(module.named_parameters(recurse=False)):
                full_name = f&#34;{module_name}.{name}&#34;
                matched = False
                for pattern in self.exclude:
                    if fnmatch(full_name, pattern) or fnmatch(name, pattern):
                        matched = True
                        break

                if param.numel() &lt;= min_params or matched:
                    if id(param) in previous:
                        continue
                    if self.detect_bound:
                        previous[id(param)] = None
                    if self.float16:
                        self._float16.append(param)
                    else:
                        self._others.append(param)
                else:
                    qparam = self._register_param(name, param, module, previous.get(id(param)))
                    if self.detect_bound:
                        previous[id(param)] = qparam
                    self._qparams.append(qparam)

    def _register_param(self, name, param, module, other):
        return self.__class__._QuantizedParam(name, param, module, other)

    def _forward_pre_hook(self, module, input):
        if self.model.training:
            self._quantized_state = None
            if self._quantized:
                self.unquantize()
            if self._pre_forward_train():
                self._fix_rnns()
        else:
            self.quantize()

    def _forward_hook(self, module, input, output):
        if self.model.training:
            if self._post_forward_train():
                self._fix_rnns(flatten=False)  # Hacky, next forward will flatten

    def quantize(self, save=True):
        &#34;&#34;&#34;
        Immediately apply quantization to the model parameters.
        If `save` is True, save a copy of the unquantized parameters, that can be
        restored with `unquantize()`.
        &#34;&#34;&#34;
        if self._quantized:
            return
        if save:
            self._saved = [qp.param.data.to(&#39;cpu&#39;, copy=True)
                           for qp in self._qparams if qp.other is None]
        self.restore_quantized_state(self.get_quantized_state())
        self._quantized = True
        self._fix_rnns()

    def unquantize(self):
        &#34;&#34;&#34;
        Revert a previous call to `quantize()`.
        &#34;&#34;&#34;
        if not self._quantized:
            raise RuntimeError(&#34;Can only be called on a quantized model.&#34;)
        if not self._saved:
            raise RuntimeError(&#34;Nothing to restore.&#34;)
        for qparam in self._qparams:
            if qparam.other is None:
                qparam.param.data[:] = self._saved.pop(0)
        assert len(self._saved) == 0
        self._quantized = False
        self._fix_rnns()

    def _pre_forward_train(self) -&gt; bool:
        &#34;&#34;&#34;
        Called once before each forward for continuous quantization.
        Should return  True if parameters were changed.
        &#34;&#34;&#34;
        return False

    def _post_forward_train(self) -&gt; bool:
        &#34;&#34;&#34;
        Called once after each forward (to restore state for instance).
        Should return True if parameters were changed.
        &#34;&#34;&#34;
        return False

    def _fix_rnns(self, flatten=True):
        &#34;&#34;&#34;
        To be called after quantization happened to fix RNNs.
        &#34;&#34;&#34;
        for rnn in self._rnns:
            rnn._flat_weights = [
                (lambda wn: getattr(rnn, wn) if hasattr(rnn, wn) else None)(wn)
                for wn in rnn._flat_weights_names]
            if flatten:
                rnn.flatten_parameters()

    def get_quantized_state(self):
        &#34;&#34;&#34;
        Returns sufficient quantized information to rebuild the model state.

        ..Note::
            To achieve maximum compression, you should compress this with
            gzip or other, as quantized weights are not optimally coded!
        &#34;&#34;&#34;
        if self._quantized_state is None:
            self._quantized_state = self._get_quantized_state()
        return self._quantized_state

    def _get_quantized_state(self):
        &#34;&#34;&#34;
        Actual implementation for `get_quantized_state`.
        &#34;&#34;&#34;
        float16_params = []
        for p in self._float16:
            q = p.data.half()
            float16_params.append(q)

        return {
            &#34;quantized&#34;: [self._quantize_param(qparam) for qparam in self._qparams
                          if qparam.other is None],
            &#34;float16&#34;: float16_params,
            &#34;others&#34;: [p.data.clone() for p in self._others],
        }

    def _quantize_param(self, qparam: _QuantizedParam) -&gt; tp.Any:
        &#34;&#34;&#34;
        To be overriden.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def _unquantize_param(self, qparam: _QuantizedParam, quantized: tp.Any) -&gt; torch.Tensor:
        &#34;&#34;&#34;
        To be overriden.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def restore_quantized_state(self, state) -&gt; None:
        &#34;&#34;&#34;
        Restore the state of the model from the quantized state.
        &#34;&#34;&#34;
        for p, q in zip(self._float16, state[&#34;float16&#34;]):
            p.data[:] = q.to(p)

        for p, q in zip(self._others, state[&#34;others&#34;]):
            p.data[:] = q

        remaining = list(state[&#34;quantized&#34;])
        for qparam in self._qparams:
            if qparam.other is not None:
                # Only unquantize first appearance of nn.Parameter.
                continue
            quantized = remaining.pop(0)
            qparam.param.data[:] = self._unquantize_param(qparam, quantized)
        self._fix_rnns()

    def detach(self) -&gt; None:
        &#34;&#34;&#34;
        Detach from the model, removes hooks and anything else.
        &#34;&#34;&#34;
        self._pre_handle.remove()
        self._post_handle.remove()

    def model_size(self) -&gt; torch.Tensor:
        &#34;&#34;&#34;
        Returns an estimate of the quantized model size.
        &#34;&#34;&#34;
        total = torch.tensor(0.)
        for p in self._float16:
            total += 16 * p.numel()
        for p in self._others:
            total += 32 * p.numel()
        return total / 2**20 / 8  # bits to MegaBytes

    def true_model_size(self) -&gt; float:
        &#34;&#34;&#34;
        Return the true quantized model size, in MB, without extra
        compression.
        &#34;&#34;&#34;
        return self.model_size().item()

    def compressed_model_size(self, compress_level=-1, num_workers=8) -&gt; float:
        &#34;&#34;&#34;
        Return the compressed quantized model size, in MB.

        Args:
            compress_level (int): compression level used with zlib,
                see `zlib.compress` for details.
            num_workers (int): will split the final big byte representation in that
                many chunks processed in parallels.
        &#34;&#34;&#34;
        out = io.BytesIO()
        torch.save(self.get_quantized_state(), out)
        ms = _parallel_compress_len(out.getvalue(), compress_level, num_workers)
        return ms / 2 ** 20


def _compress_len(data, compress_level):
    return len(zlib.compress(data, level=compress_level))


def _parallel_compress_len(data, compress_level, num_workers):
    num_workers = min(cpu_count(), num_workers)
    chunk_size = int(math.ceil(len(data) / num_workers))
    chunks = [data[offset:offset + chunk_size] for offset in range(0, len(data), chunk_size)]
    with futures.ProcessPoolExecutor(num_workers) as pool:
        return sum(pool.map(partial(_compress_len, compress_level=compress_level), chunks))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="diffq.base.BaseQuantizer"><code class="flex name class">
<span>class <span class="ident">BaseQuantizer</span></span>
<span>(</span><span>model: torch.nn.modules.module.Module, min_size: float = 0.01, float16: bool = False, exclude: Union[List[str], NoneType] = [], detect_bound: bool = True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseQuantizer:
    @dataclass
    class _QuantizedParam:
        name: str
        param: torch.nn.Parameter
        module: torch.nn.Module
        # If a Parameter is used multiple times, `other` can be used
        # to share state between the different Quantizers
        other: tp.Optional[tp.Any]

    def __init__(self, model: torch.nn.Module, min_size: float = 0.01, float16: bool = False,
                 exclude: tp.Optional[tp.List[str]] = [], detect_bound: bool = True):
        self.model = model
        self.min_size = min_size
        self.float16 = float16
        self.exclude = exclude
        self.detect_bound = detect_bound
        self._quantized = False
        self._pre_handle = self.model.register_forward_pre_hook(self._forward_pre_hook)
        self._post_handle = self.model.register_forward_hook(self._forward_hook)

        self._quantized_state = None
        self._qparams = []
        self._float16 = []
        self._others = []
        self._rnns = []

        self._saved = []

        self._find_params()

    def _find_params(self):
        min_params = self.min_size * 2**20 // 4
        previous = {}
        for module_name, module in self.model.named_modules():
            if isinstance(module, torch.nn.RNNBase):
                self._rnns.append(module)
            for name, param in list(module.named_parameters(recurse=False)):
                full_name = f&#34;{module_name}.{name}&#34;
                matched = False
                for pattern in self.exclude:
                    if fnmatch(full_name, pattern) or fnmatch(name, pattern):
                        matched = True
                        break

                if param.numel() &lt;= min_params or matched:
                    if id(param) in previous:
                        continue
                    if self.detect_bound:
                        previous[id(param)] = None
                    if self.float16:
                        self._float16.append(param)
                    else:
                        self._others.append(param)
                else:
                    qparam = self._register_param(name, param, module, previous.get(id(param)))
                    if self.detect_bound:
                        previous[id(param)] = qparam
                    self._qparams.append(qparam)

    def _register_param(self, name, param, module, other):
        return self.__class__._QuantizedParam(name, param, module, other)

    def _forward_pre_hook(self, module, input):
        if self.model.training:
            self._quantized_state = None
            if self._quantized:
                self.unquantize()
            if self._pre_forward_train():
                self._fix_rnns()
        else:
            self.quantize()

    def _forward_hook(self, module, input, output):
        if self.model.training:
            if self._post_forward_train():
                self._fix_rnns(flatten=False)  # Hacky, next forward will flatten

    def quantize(self, save=True):
        &#34;&#34;&#34;
        Immediately apply quantization to the model parameters.
        If `save` is True, save a copy of the unquantized parameters, that can be
        restored with `unquantize()`.
        &#34;&#34;&#34;
        if self._quantized:
            return
        if save:
            self._saved = [qp.param.data.to(&#39;cpu&#39;, copy=True)
                           for qp in self._qparams if qp.other is None]
        self.restore_quantized_state(self.get_quantized_state())
        self._quantized = True
        self._fix_rnns()

    def unquantize(self):
        &#34;&#34;&#34;
        Revert a previous call to `quantize()`.
        &#34;&#34;&#34;
        if not self._quantized:
            raise RuntimeError(&#34;Can only be called on a quantized model.&#34;)
        if not self._saved:
            raise RuntimeError(&#34;Nothing to restore.&#34;)
        for qparam in self._qparams:
            if qparam.other is None:
                qparam.param.data[:] = self._saved.pop(0)
        assert len(self._saved) == 0
        self._quantized = False
        self._fix_rnns()

    def _pre_forward_train(self) -&gt; bool:
        &#34;&#34;&#34;
        Called once before each forward for continuous quantization.
        Should return  True if parameters were changed.
        &#34;&#34;&#34;
        return False

    def _post_forward_train(self) -&gt; bool:
        &#34;&#34;&#34;
        Called once after each forward (to restore state for instance).
        Should return True if parameters were changed.
        &#34;&#34;&#34;
        return False

    def _fix_rnns(self, flatten=True):
        &#34;&#34;&#34;
        To be called after quantization happened to fix RNNs.
        &#34;&#34;&#34;
        for rnn in self._rnns:
            rnn._flat_weights = [
                (lambda wn: getattr(rnn, wn) if hasattr(rnn, wn) else None)(wn)
                for wn in rnn._flat_weights_names]
            if flatten:
                rnn.flatten_parameters()

    def get_quantized_state(self):
        &#34;&#34;&#34;
        Returns sufficient quantized information to rebuild the model state.

        ..Note::
            To achieve maximum compression, you should compress this with
            gzip or other, as quantized weights are not optimally coded!
        &#34;&#34;&#34;
        if self._quantized_state is None:
            self._quantized_state = self._get_quantized_state()
        return self._quantized_state

    def _get_quantized_state(self):
        &#34;&#34;&#34;
        Actual implementation for `get_quantized_state`.
        &#34;&#34;&#34;
        float16_params = []
        for p in self._float16:
            q = p.data.half()
            float16_params.append(q)

        return {
            &#34;quantized&#34;: [self._quantize_param(qparam) for qparam in self._qparams
                          if qparam.other is None],
            &#34;float16&#34;: float16_params,
            &#34;others&#34;: [p.data.clone() for p in self._others],
        }

    def _quantize_param(self, qparam: _QuantizedParam) -&gt; tp.Any:
        &#34;&#34;&#34;
        To be overriden.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def _unquantize_param(self, qparam: _QuantizedParam, quantized: tp.Any) -&gt; torch.Tensor:
        &#34;&#34;&#34;
        To be overriden.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def restore_quantized_state(self, state) -&gt; None:
        &#34;&#34;&#34;
        Restore the state of the model from the quantized state.
        &#34;&#34;&#34;
        for p, q in zip(self._float16, state[&#34;float16&#34;]):
            p.data[:] = q.to(p)

        for p, q in zip(self._others, state[&#34;others&#34;]):
            p.data[:] = q

        remaining = list(state[&#34;quantized&#34;])
        for qparam in self._qparams:
            if qparam.other is not None:
                # Only unquantize first appearance of nn.Parameter.
                continue
            quantized = remaining.pop(0)
            qparam.param.data[:] = self._unquantize_param(qparam, quantized)
        self._fix_rnns()

    def detach(self) -&gt; None:
        &#34;&#34;&#34;
        Detach from the model, removes hooks and anything else.
        &#34;&#34;&#34;
        self._pre_handle.remove()
        self._post_handle.remove()

    def model_size(self) -&gt; torch.Tensor:
        &#34;&#34;&#34;
        Returns an estimate of the quantized model size.
        &#34;&#34;&#34;
        total = torch.tensor(0.)
        for p in self._float16:
            total += 16 * p.numel()
        for p in self._others:
            total += 32 * p.numel()
        return total / 2**20 / 8  # bits to MegaBytes

    def true_model_size(self) -&gt; float:
        &#34;&#34;&#34;
        Return the true quantized model size, in MB, without extra
        compression.
        &#34;&#34;&#34;
        return self.model_size().item()

    def compressed_model_size(self, compress_level=-1, num_workers=8) -&gt; float:
        &#34;&#34;&#34;
        Return the compressed quantized model size, in MB.

        Args:
            compress_level (int): compression level used with zlib,
                see `zlib.compress` for details.
            num_workers (int): will split the final big byte representation in that
                many chunks processed in parallels.
        &#34;&#34;&#34;
        out = io.BytesIO()
        torch.save(self.get_quantized_state(), out)
        ms = _parallel_compress_len(out.getvalue(), compress_level, num_workers)
        return ms / 2 ** 20</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="diffq.diffq.DiffQuantizer" href="diffq.html#diffq.diffq.DiffQuantizer">DiffQuantizer</a></li>
<li><a title="diffq.uniform.UniformQuantizer" href="uniform.html#diffq.uniform.UniformQuantizer">UniformQuantizer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="diffq.base.BaseQuantizer.compressed_model_size"><code class="name flex">
<span>def <span class="ident">compressed_model_size</span></span>(<span>self, compress_level=-1, num_workers=8) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Return the compressed quantized model size, in MB.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>compress_level</code></strong> :&ensp;<code>int</code></dt>
<dd>compression level used with zlib,
see <code>zlib.compress</code> for details.</dd>
<dt><strong><code>num_workers</code></strong> :&ensp;<code>int</code></dt>
<dd>will split the final big byte representation in that
many chunks processed in parallels.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compressed_model_size(self, compress_level=-1, num_workers=8) -&gt; float:
    &#34;&#34;&#34;
    Return the compressed quantized model size, in MB.

    Args:
        compress_level (int): compression level used with zlib,
            see `zlib.compress` for details.
        num_workers (int): will split the final big byte representation in that
            many chunks processed in parallels.
    &#34;&#34;&#34;
    out = io.BytesIO()
    torch.save(self.get_quantized_state(), out)
    ms = _parallel_compress_len(out.getvalue(), compress_level, num_workers)
    return ms / 2 ** 20</code></pre>
</details>
</dd>
<dt id="diffq.base.BaseQuantizer.detach"><code class="name flex">
<span>def <span class="ident">detach</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Detach from the model, removes hooks and anything else.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detach(self) -&gt; None:
    &#34;&#34;&#34;
    Detach from the model, removes hooks and anything else.
    &#34;&#34;&#34;
    self._pre_handle.remove()
    self._post_handle.remove()</code></pre>
</details>
</dd>
<dt id="diffq.base.BaseQuantizer.get_quantized_state"><code class="name flex">
<span>def <span class="ident">get_quantized_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns sufficient quantized information to rebuild the model state.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To achieve maximum compression, you should compress this with
gzip or other, as quantized weights are not optimally coded!</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_quantized_state(self):
    &#34;&#34;&#34;
    Returns sufficient quantized information to rebuild the model state.

    ..Note::
        To achieve maximum compression, you should compress this with
        gzip or other, as quantized weights are not optimally coded!
    &#34;&#34;&#34;
    if self._quantized_state is None:
        self._quantized_state = self._get_quantized_state()
    return self._quantized_state</code></pre>
</details>
</dd>
<dt id="diffq.base.BaseQuantizer.model_size"><code class="name flex">
<span>def <span class="ident">model_size</span></span>(<span>self) ‑> torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an estimate of the quantized model size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_size(self) -&gt; torch.Tensor:
    &#34;&#34;&#34;
    Returns an estimate of the quantized model size.
    &#34;&#34;&#34;
    total = torch.tensor(0.)
    for p in self._float16:
        total += 16 * p.numel()
    for p in self._others:
        total += 32 * p.numel()
    return total / 2**20 / 8  # bits to MegaBytes</code></pre>
</details>
</dd>
<dt id="diffq.base.BaseQuantizer.quantize"><code class="name flex">
<span>def <span class="ident">quantize</span></span>(<span>self, save=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Immediately apply quantization to the model parameters.
If <code>save</code> is True, save a copy of the unquantized parameters, that can be
restored with <code>unquantize()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quantize(self, save=True):
    &#34;&#34;&#34;
    Immediately apply quantization to the model parameters.
    If `save` is True, save a copy of the unquantized parameters, that can be
    restored with `unquantize()`.
    &#34;&#34;&#34;
    if self._quantized:
        return
    if save:
        self._saved = [qp.param.data.to(&#39;cpu&#39;, copy=True)
                       for qp in self._qparams if qp.other is None]
    self.restore_quantized_state(self.get_quantized_state())
    self._quantized = True
    self._fix_rnns()</code></pre>
</details>
</dd>
<dt id="diffq.base.BaseQuantizer.restore_quantized_state"><code class="name flex">
<span>def <span class="ident">restore_quantized_state</span></span>(<span>self, state) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Restore the state of the model from the quantized state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restore_quantized_state(self, state) -&gt; None:
    &#34;&#34;&#34;
    Restore the state of the model from the quantized state.
    &#34;&#34;&#34;
    for p, q in zip(self._float16, state[&#34;float16&#34;]):
        p.data[:] = q.to(p)

    for p, q in zip(self._others, state[&#34;others&#34;]):
        p.data[:] = q

    remaining = list(state[&#34;quantized&#34;])
    for qparam in self._qparams:
        if qparam.other is not None:
            # Only unquantize first appearance of nn.Parameter.
            continue
        quantized = remaining.pop(0)
        qparam.param.data[:] = self._unquantize_param(qparam, quantized)
    self._fix_rnns()</code></pre>
</details>
</dd>
<dt id="diffq.base.BaseQuantizer.true_model_size"><code class="name flex">
<span>def <span class="ident">true_model_size</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Return the true quantized model size, in MB, without extra
compression.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def true_model_size(self) -&gt; float:
    &#34;&#34;&#34;
    Return the true quantized model size, in MB, without extra
    compression.
    &#34;&#34;&#34;
    return self.model_size().item()</code></pre>
</details>
</dd>
<dt id="diffq.base.BaseQuantizer.unquantize"><code class="name flex">
<span>def <span class="ident">unquantize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Revert a previous call to <code>quantize()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unquantize(self):
    &#34;&#34;&#34;
    Revert a previous call to `quantize()`.
    &#34;&#34;&#34;
    if not self._quantized:
        raise RuntimeError(&#34;Can only be called on a quantized model.&#34;)
    if not self._saved:
        raise RuntimeError(&#34;Nothing to restore.&#34;)
    for qparam in self._qparams:
        if qparam.other is None:
            qparam.param.data[:] = self._saved.pop(0)
    assert len(self._saved) == 0
    self._quantized = False
    self._fix_rnns()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="diffq" href="index.html">diffq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="diffq.base.BaseQuantizer" href="#diffq.base.BaseQuantizer">BaseQuantizer</a></code></h4>
<ul class="">
<li><code><a title="diffq.base.BaseQuantizer.compressed_model_size" href="#diffq.base.BaseQuantizer.compressed_model_size">compressed_model_size</a></code></li>
<li><code><a title="diffq.base.BaseQuantizer.detach" href="#diffq.base.BaseQuantizer.detach">detach</a></code></li>
<li><code><a title="diffq.base.BaseQuantizer.get_quantized_state" href="#diffq.base.BaseQuantizer.get_quantized_state">get_quantized_state</a></code></li>
<li><code><a title="diffq.base.BaseQuantizer.model_size" href="#diffq.base.BaseQuantizer.model_size">model_size</a></code></li>
<li><code><a title="diffq.base.BaseQuantizer.quantize" href="#diffq.base.BaseQuantizer.quantize">quantize</a></code></li>
<li><code><a title="diffq.base.BaseQuantizer.restore_quantized_state" href="#diffq.base.BaseQuantizer.restore_quantized_state">restore_quantized_state</a></code></li>
<li><code><a title="diffq.base.BaseQuantizer.true_model_size" href="#diffq.base.BaseQuantizer.true_model_size">true_model_size</a></code></li>
<li><code><a title="diffq.base.BaseQuantizer.unquantize" href="#diffq.base.BaseQuantizer.unquantize">unquantize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>